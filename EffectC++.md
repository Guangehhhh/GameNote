## EffectC++

#资源管理类需要提供对原始资源的访问 Effective C++笔记

Item 43：访问模板基类中的名称 Effective C++笔记

Item 42：typename的两种用法 Effective C++笔记

Item 41：隐式接口与编译期多态 Effective C++笔记

Item 40：明智地使用多继承 Effective C++笔记

Item 39：明智地使用private继承 Effective C++笔记

Item 38：通过组合表示"拥有"或"以...实现"的关系 Effective C++笔记

Item 37：不要重写父类函数的默认参数

Item 36：不要重写继承来的非虚函数

Item 35：考虑虚函数的其他替代设计 Effective C++笔记

Item 34：区分接口继承和实现继承 Effective C++笔记

Item 33：避免隐藏继承来的名称（继承与作用域嵌套） Effective C++笔记

Item 32：确保public继承是"is a"的关系 Effective C++笔记

Item 31：最小化文件之间的编译依赖 Effective C++笔记

Item 30：理解inline函数的里里外外 Effective C++笔记

Item 29：追求异常安全的代码 Effective C++笔记

Item 28：不要返回对象内部的句柄 Effective C++笔记

Item 27：最小化类型转换 Effective C++笔记

Item 26：为什么要推迟变量的定义？ Effective C++笔记

Item 25：考虑实现一个不抛异常的swap Effective C++笔记

Item 24：用非成员函数来支持所有元的类型转换 Effective C++笔记

Item 23：非成员非友元函数好于成员函数 Effective C++笔记

Item 22：数据成员应声明为私有 Effective C++笔记

Item 21：需要返回对象时，不要返回引用 Effective C++笔记

Item 20：传递常量引用比传值更好 Effective C++笔记

Item 19：把类的设计视作类型设计 Effective C++笔记

Item 18：让接口容易被正确使用，不易被误用 Effective C++笔记

Item 17：在单独的语句中将new的对象放入智能指针 Effective C++笔记

Item 16：为什么要使用同样的形式来new和delete Effective C++笔记

资源管理类需要提供对原始资源的访问 Effective C++笔记

Item 14：资源管理类要特别注意拷贝行为 Effective C++笔记

Item 13：使用对象（智能指针）来管理资源 Effective C++笔记

Item 12：完整地拷贝对象（拷贝构造函数、复制运算符） Effective C++笔记

Item 11：赋值运算符的自赋值问题 Effective C++笔记

Item 10：赋值运算符要返回自己的引用 Effective C++笔记

Item 9：在析构/构造时不要调用虚函数 Effective C++笔记

Item 8：析构函数不要抛出异常 Effective C++笔记

Item 7：将多态基类的析构函数声明为虚函数 Effective C++笔记

Item 6：禁用那些不需要的缺省方法 Effective C++笔记

Item 5：那些被C++默默地声明和调用的函数 Effective C++笔记

Item 4：确保变量的初始化 Effective C++笔记

Item 3：尽量使用常量 Effective C++笔记

Item 2：避免使用define Effective C++笔记

Item 1：将C++视作一系列的语言 Effective C++笔记
