## 5/24 IK系统研究
- 反向动力学，Inverse Kinematics
  - 正向动力学（Forward Kinematics，FK），由父骨骼的方位和子骨骼的相对变换得到子骨骼的方位
  - 而IK则是先确定子骨骼的方位，反向推导出其继承链上n级父骨骼方位的方法
  - 就如同人平时的行为一样——往往是手掌的位置和旋转需要先确定（拍到墙壁上的某个点，抓住某个东西等……）后
    - 再进行手肘变换的计算。这也就意味着IK的结算可能产生未知个数的解（0个或多个……）
    - 有可能手掌根本抓不到一个地方，或者手掌到了一个地方手肘可以有多个形态和变换



- 现在最常用的IK实现方法称为CCD（Cyclic Coordinate Descent，循环坐标下降）
  - 从骨骼链上最深的子骨节开始进行处理，将这段骨节相对于原点进行旋转从而使它指向效应点。
  - 将这个骨节的父节点针对于原点进行旋转，以使得此父骨节的原点到新旋转的子骨节端点的连线指向效应点即可。
    - 旋转当前骨骼，使当前骨骼位置到目标骨骼的连线指向IK目标位置
    - 由于通常骨骼动画都是用四元数来表示旋转，而关节的角度限制只能用欧拉角来表示
    - 所以在迭代过程中每次算出骨骼的旋转后都要转成欧拉角，看是否超过极限值，如果超过则需要校正，然后再转回四元数进行计算。
    - 限制了旋转角之后，结果看起来就很好了
      - 但是还有一个细节需要注意，当所有需要IK控制的骨骼正好在一条直线上
      - 而IK目标位置正好在也落在这条直线上时，算法就会失败
      - 因为不论迭代多少次，每一个骨骼都会认为自己不需要旋转。
      - 所以一个小技巧是，如果发现骨骼链“很直”，就向骨骼允许的任意方向加一些细微的旋转
      - 或者干脆在骨骼的限制角度数据中就禁止完全“伸直”
  - 对每个骨节进行1~2步骤的处理。
  - 上述步骤进行多次循环从而得到更加稳定的值
  - 一般来说骨骼的运动是有约束的，因此可以在进行上述步骤1时进行约束
- 使用雅可比矩阵(Jacobian)来进行IK结算














# UE的IK   
  * 首先写一个从Socket到地面的射线碰撞  
  * 返回一个旋转值和浮点数
  * 然后Interp插值旋转值
  * Interp 插值浮点数
  * Hip Zoffset函数
  * 本地到组件空间
* 时间回复功能
  * 物体每秒计算tick保存到transform 数组里；
  * 在按键后读取数组删除读取的数 循环设置transform

  * 在工具->选项->项目和解决方案->VC++目录
  里面把包含文件和库文件路径添加
  *  project->property->linker->general->Additional library directories 填写lib路径
  project->property->linker->input 填写lib名称
