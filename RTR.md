## RTR

# 图形渲染管线
- 架构
  - 应用，几何，光栅化
  - 最慢的管线阶段决定绘制速度
- 应用阶段
  - 通过软件方式来实现的阶段
  - 用户可完全掌控，运行在CPU
  - 可以在几个并行处理器上同时执行
  - 应用程序阶段虽然是一个单独的过程，但是依然可以对之进行管线化或者并行化处理
  - 有碰撞检测、加速算法、输入检测，动画，力反馈以及纹理动画，变换仿真、几何变形   
    - 以及一些不在其他阶段执行的计算，如层次视锥裁剪等加速算法就可以在这里实现
      - 对应虚幻的 InitView 可见性判断
  - 阶段的末端，将需要在屏幕上（具体形式取决于具体输入设备）显示出来绘制的几何体
    - 也就是绘制图元，rendering  primitives，如点、线、矩形等 输入到绘制管线的下一个阶段
  - 对于被渲染的每一帧，应用程序阶段将摄像机位置，光照和模型的图元输出到管线的下一个主要阶段——几何阶段。
- 几何阶段
  - 一些情况下，一系列连续的功能阶段可以形成单个管线阶段（和其他管线阶段并行运行）
    - 在另外情况下，一个功能阶段可以划分成其他更细小的管线阶段
  - 几何阶段执行的是计算量非常高的任务，在只有一个光源的情况下
    - 每个顶点大约需要100次左右的精确的浮点运算操作
  - 模型变换 视图变换
    - 模型变换的目的是将模型变换到适合渲染的空间当中
    - 视图变换的目的是将摄像机放置于坐标原点，方便后续步骤的操作
    - 在屏幕上的显示过程中，模型通常需要变换到若干不同的空间或坐标系中
      - 模型变换的变换对象一般是模型的顶点和法线
      - 物体的坐标称为模型坐标
      - 世界空间是唯一的，所有的模型经过变换后都位于同一个空间中
    - 不难理解，应该仅对相机（或者视点）可以看到的模型进行绘制
      - 相机在世界空间中有一个位置方向，用来放置和校准相机
    - 为了便于投影和裁剪，必须对相机和所有的模型进行视点变换
      - 变换的目的就是要把相机放在原点，然后进行视点校准
        - 使其朝向Z轴负方向，y轴指向上方,x轴指向右边
        - 在视点变换后，实际位置和方向就依赖于当前的API
        - 称上述空间为相机空间或者观察空间
  - 顶点着色
    - 为了产生逼真的场景，渲染形状和位置是远远不够的，我们需要对物体的外观进行建模
    - 物体经过建模，会得到对每个对象的材质
      - 照射在对象上的任何光源的效果在内的一些描述
      - 且光照和材质可以用任意数量的方式，从简单的颜色描述到复杂的物理描述来模拟
    - 确定材质上的光照效果的这种操作被称为着色（shading）
      - 着色过程涉及在对象上的各个点处计算着色方程（shadingequation）
    - 这些计算中的一些在几何阶段期间在模型的顶点上执行（vertexshading）
    - 其他计算可以在每像素光栅化（per-pixelrasterization）期间执行
    - 也可以在每个顶点处存储各种材料数据，诸如点的位置，法线，颜色或计算着色方程所需的任何其它数字信息
    - 顶点着色的结果（其可以是颜色，向量，纹理坐标或任何其他种类的阴着色数据）计算完成后，会被发送到光栅化阶段以进行插值操作

    - 着色计算通常认为是在世界空间中进行的
    - 有时需要将相关实体（诸如相机和光源）转换到一些其它空间（诸如模型或观察空间）并在那里执行计算
    - 这是因为如果着色过程中所有的实体变换到了相同的空间
      - 着色计算中需要的诸如光源，相机和模型之间的相对关系是不会变的。
    - 顶点着色阶段的目的在于确定模型上顶点处材质的光照效果
  - 投影变换
    - 在光照处理之后，就开始进行投影操作
      - 即将视体变换到一个对角顶点分别是(-1,-1,-1)和(1,1,1)单位立方体（unitcube）内
      - 这个单位立方体通常也被称为规范立方体（Canonical View Volume，CVV）

    - 目前，主要有两种投影方法，即：
    - 正交投影
      - 可视体通常是一个矩形，正交投影可以把这个视体变换为单位立方体
      - 正交投影的主要特性是平行线在变换之后彼此之间仍然保持平行，这种变换是平移与缩放的组合
    - 透视投影
      - 透视投影比正交投影复杂一些。在这种投影中，越远离摄像机的物体，它在投影后看起来越小。
      - 更进一步来说，平行线将在地平线处会聚。透视投影的变换其实就是模拟人类感知物体的方式。

    - 正交投影和透视投影都可以通过4x4的矩阵来实现
      - 在任何一种变换之后，都可以认为模型位于归一化处理之后的设备坐标系中

    - 虽然这些矩阵变换是从一个可视体变换到另一个，但它们仍被称为投影
      - 因为在完成显示后，Z坐标将不会再保存于的得到的投影图片中
    - 通过这样的投影方法，就将模型从三维空间投影到了二维的空间中

  - 裁剪
    - 裁剪阶段的目的，就是对部分位于视体内部的图元进行裁剪操作
    - 只有当图元完全或部分存在于视体（也就是上文的规范立方体，CVV）内部的时候，
      - 才需要将其发送到光栅化阶段，这个阶段可以把这些图元在屏幕上绘制出来。

    - 一个图元相对视体内部的位置，分为三种情况：完全位于内部、完全位于外部、部分位于内部
      - 所以就要分情况进行处理：
        -   当图元完全位于视体内部，那么它可以直接进行下一个阶段。
        -   当图元完全位于视体外部，不会进入下一个阶段，可直接丢弃，因为它们无需进行渲染。
        -   当图元部分位于视体内部，则需要对那些部分位于视体内的图元进行裁剪处理
  - 屏幕映射
    - 只有在视体内部经过裁剪的图元，以及之前完全位于视体内部的图元，才可以进入到屏幕映射阶段
      - 进入到这个阶段时，坐标仍然是三维的（但显示状态在经过投影阶段后已经成了二维）
      - 每个图元的x和y坐标变换到了屏幕坐标系中，屏幕坐标系连同z坐标一起称为窗口坐标系

    - 假定在一个窗口里对场景进行绘制，窗口的最小坐标为（x1，y1），最大坐标为（x2，y2），其中x1\<x2，y1\<y2。屏幕映射首先进行平移，随后进行缩放，在映射过程中z坐标不受影响。新的x和y坐标称为屏幕坐标系，与z坐标一起（-1≦
    z ≦ 1）进入光栅化阶段。

    - 经过投影变换，图元全部位于单位立方体之内，而屏幕映射主要目的就是找到屏幕上对应的坐标

    - 屏幕映射阶段的一个常见困惑是整型和浮点型的点值如何与像素坐标（或纹理坐标）进行关联。可以使用Heckbert[书后参考文献第520篇]的策略，用一个转换公式进行解决

    - 屏幕映射阶段的主要目的，就是将之前步骤得到的坐标映射到对应的屏幕坐标系上。
- 光栅化
  - 用经过变换和投影之后的顶点，颜色以及纹理坐标（均来自于几何阶段）给每个像素（Pixel）正确配色，正确绘制整幅图像
    - 这个过个过程叫光珊化（rasterization）或扫描变换（scanconversion）
    - 即从二维顶点所处的屏幕空间（所有顶点都包含Z值即深度值，及各种与相关的着色信息）到屏幕上的像素的转换
  - 三角形Setup
    - 三角形设定阶段主要用来计算三角形表面的差异和三角形表面的其他相关数据
    - 该数据主要用于扫描转换scanconversion，以及由几何阶段处理的各种着色数据的插值操作所用
    - 该过程在专门为其设计的硬件上执行
  - 三角形遍历
    - 逐像素检查操作，检查该像素处的像素中心是否由三角形覆盖
      - 而对于有三角形部分重合的像素，将在其重合部分生成片段（fragment）
    - 找到采样点或像素在三角形中的过程通常叫三角形遍历TriangleTraversal或扫描转换
    - 每个三角形片段的属性均由三个三角形顶点的数据插值而生成
      - 这些属性包括片段的深度，以及来自几何阶段的着色数据

  - 像素着色
    - 所有逐像素的着色计算都在像素着色阶段进行，使用插值得来的着色数据作为输入
    - 输出结果为一种或多种将被传送到下一阶段的颜色信息
    - 纹理贴图操作就是在这阶段进行的

    - 像素着色阶段是在可编程GPU内执行的，在这一阶段有大量的技术可以使用，其中最常见，最重要的技术之一就是纹理贴图（Texturing）
      - 纹理贴图就是将指定图片“贴”到指定物体上的过程
      - 而指定的图片可以是一维，二维，或者三维的，其中，自然是二维图片最为常见
    - 像素着色阶段的主要目的是计算所有需逐像素操作的过程
  - 混合
# GPU渲染管线与可编程着色器
-
# 图形渲染与视觉外观
-
# 纹理贴图及相关技术
-
# 高级着色：BRDF及相关技术
-
# 延迟渲染
-
#  全局光照:光线追踪、路径追踪与GI
-

# 基于图像的渲染技术总结
# 非真实感渲染(NPR)
# 渲染加速算法
# 渲染管线优化方法
