## RTR

## 图形渲染管线
# 架构
  - 应用，几何，光栅化
  - 最慢的管线阶段决定绘制速度
# 应用阶段
  - 通过软件方式来实现的阶段
  - 用户可完全掌控，运行在CPU
  - 可以在几个并行处理器上同时执行
  - 应用程序阶段虽然是一个单独的过程，但是依然可以对之进行管线化或者并行化处理
  - 有碰撞检测、加速算法、输入检测，动画，力反馈以及纹理动画，变换仿真、几何变形   
    - 以及一些不在其他阶段执行的计算，如层次视锥裁剪等加速算法就可以在这里实现
      - 对应虚幻的 InitView 可见性判断
  - 阶段的末端，将需要在屏幕上（具体形式取决于具体输入设备）显示出来绘制的几何体
    - 也就是绘制图元，rendering  primitives，如点、线、矩形等 输入到绘制管线的下一个阶段
  - 对于被渲染的每一帧，应用程序阶段将摄像机位置，光照和模型的图元输出到管线的下一个主要阶段——几何阶段。
# 几何阶段
  - 一些情况下，一系列连续的功能阶段可以形成单个管线阶段（和其他管线阶段并行运行）
    - 在另外情况下，一个功能阶段可以划分成其他更细小的管线阶段
  - 几何阶段执行的是计算量非常高的任务，在只有一个光源的情况下
    - 每个顶点大约需要100次左右的精确的浮点运算操作
  - 模型变换 视图变换
    - 模型变换的目的是将模型变换到适合渲染的空间当中
    - 视图变换的目的是将摄像机放置于坐标原点，方便后续步骤的操作
    - 在屏幕上的显示过程中，模型通常需要变换到若干不同的空间或坐标系中
      - 模型变换的变换对象一般是模型的顶点和法线
      - 物体的坐标称为模型坐标
      - 世界空间是唯一的，所有的模型经过变换后都位于同一个空间中
    - 不难理解，应该仅对相机（或者视点）可以看到的模型进行绘制
      - 相机在世界空间中有一个位置方向，用来放置和校准相机
    - 为了便于投影和裁剪，必须对相机和所有的模型进行视点变换
      - 变换的目的就是要把相机放在原点，然后进行视点校准
        - 使其朝向Z轴负方向，y轴指向上方,x轴指向右边
        - 在视点变换后，实际位置和方向就依赖于当前的API
        - 称上述空间为相机空间或者观察空间
  - 顶点着色
    - 为了产生逼真的场景，渲染形状和位置是远远不够的，我们需要对物体的外观进行建模
    - 物体经过建模，会得到对每个对象的材质
      - 照射在对象上的任何光源的效果在内的一些描述
      - 且光照和材质可以用任意数量的方式，从简单的颜色描述到复杂的物理描述来模拟
    - 确定材质上的光照效果的这种操作被称为着色（shading）
      - 着色过程涉及在对象上的各个点处计算着色方程（shadingequation）
    - 这些计算中的一些在几何阶段期间在模型的顶点上执行（vertexshading）
    - 其他计算可以在每像素光栅化（per-pixelrasterization）期间执行
    - 也可以在每个顶点处存储各种材料数据，诸如点的位置，法线，颜色或计算着色方程所需的任何其它数字信息
    - 顶点着色的结果（其可以是颜色，向量，纹理坐标或任何其他种类的阴着色数据）计算完成后，会被发送到光栅化阶段以进行插值操作

    - 着色计算通常认为是在世界空间中进行的
    - 有时需要将相关实体（诸如相机和光源）转换到一些其它空间（诸如模型或观察空间）并在那里执行计算
    - 这是因为如果着色过程中所有的实体变换到了相同的空间
      - 着色计算中需要的诸如光源，相机和模型之间的相对关系是不会变的。
    - 顶点着色阶段的目的在于确定模型上顶点处材质的光照效果
  - 投影变换
    - 在光照处理之后，就开始进行投影操作
      - 即将视体变换到一个对角顶点分别是(-1,-1,-1)和(1,1,1)单位立方体（unitcube）内
      - 这个单位立方体通常也被称为规范立方体（Canonical View Volume，CVV）

    - 目前，主要有两种投影方法，即：
    - 正交投影
      - 可视体通常是一个矩形，正交投影可以把这个视体变换为单位立方体
      - 正交投影的主要特性是平行线在变换之后彼此之间仍然保持平行，这种变换是平移与缩放的组合
    - 透视投影
      - 透视投影比正交投影复杂一些。在这种投影中，越远离摄像机的物体，它在投影后看起来越小。
      - 更进一步来说，平行线将在地平线处会聚。透视投影的变换其实就是模拟人类感知物体的方式。

    - 正交投影和透视投影都可以通过4x4的矩阵来实现
      - 在任何一种变换之后，都可以认为模型位于归一化处理之后的设备坐标系中

    - 虽然这些矩阵变换是从一个可视体变换到另一个，但它们仍被称为投影
      - 因为在完成显示后，Z坐标将不会再保存于的得到的投影图片中
    - 通过这样的投影方法，就将模型从三维空间投影到了二维的空间中

  - 裁剪
    - 裁剪阶段的目的，就是对部分位于视体内部的图元进行裁剪操作
    - 只有当图元完全或部分存在于视体（也就是上文的规范立方体，CVV）内部的时候，
      - 才需要将其发送到光栅化阶段，这个阶段可以把这些图元在屏幕上绘制出来。

    - 一个图元相对视体内部的位置，分为三种情况：完全位于内部、完全位于外部、部分位于内部
      - 所以就要分情况进行处理：
        -   当图元完全位于视体内部，那么它可以直接进行下一个阶段。
        -   当图元完全位于视体外部，不会进入下一个阶段，可直接丢弃，因为它们无需进行渲染。
        -   当图元部分位于视体内部，则需要对那些部分位于视体内的图元进行裁剪处理
  - 屏幕映射
    - 只有在视体内部经过裁剪的图元，才可以进入到屏幕映射阶段
      - 进入到这个阶段时，坐标仍然是三维的（但显示状态在经过投影阶段后已经成了二维）
      - 每个图元的x和y坐标变换到了屏幕坐标系中，屏幕坐标系连同z坐标一起称为窗口坐标系

    - 假定在一个窗口里对场景进行绘制，窗口的最小坐标为（x1，y1），最大坐标为（x2，y2），其中x1\<x2，y1\<y2。屏幕映射首先进行平移，随后进行缩放，在映射过程中z坐标不受影响。新的x和y坐标称为屏幕坐标系，与z坐标一起（-1≦
    z ≦ 1）进入光栅化阶段。

    - 经过投影变换，图元全部位于单位立方体之内，而屏幕映射主要目的就是找到屏幕上对应的坐标

    - 屏幕映射阶段的一个常见困惑是整型和浮点型的点值如何与像素坐标（或纹理坐标）进行关联。可以使用Heckbert[书后参考文献第520篇]的策略，用一个转换公式进行解决

    - 屏幕映射阶段的主要目的，就是将之前步骤得到的坐标映射到对应的屏幕坐标系上。
# 光栅化
  - 用经过变换和投影之后的顶点，颜色以及纹理坐标（均来自于几何阶段）给每个像素（Pixel）正确配色，正确绘制整幅图像
    - 这个过个过程叫光珊化（rasterization）或扫描变换（scanconversion）
    - 即从二维顶点所处的屏幕空间（所有顶点都包含Z值即深度值，及各种与相关的着色信息）到屏幕上的像素的转换
  - 三角形Setup
    - 三角形设定阶段主要用来计算三角形表面的差异和三角形表面的其他相关数据
    - 该数据主要用于扫描转换scanconversion，以及由几何阶段处理的各种着色数据的插值操作所用
    - 该过程在专门为其设计的硬件上执行
  - 三角形遍历
    - 逐像素检查操作，检查该像素处的像素中心是否由三角形覆盖
      - 而对于有三角形部分重合的像素，将在其重合部分生成片段（fragment）
    - 找到采样点或像素在三角形中的过程通常叫三角形遍历TriangleTraversal或扫描转换
    - 每个三角形片段的属性均由三个三角形顶点的数据插值而生成
      - 这些属性包括片段的深度，以及来自几何阶段的着色数据

  - 像素着色
    - 所有逐像素的着色计算都在像素着色阶段进行，使用插值得来的着色数据作为输入
    - 输出结果为一种或多种将被传送到下一阶段的颜色信息
    - 纹理贴图操作就是在这阶段进行的

    - 像素着色阶段是在可编程GPU内执行的，在这一阶段有大量的技术可以使用
    - 其中最常见，最重要的技术之一就是纹理贴图（Texturing）
      - 纹理贴图就是将指定图片“贴”到指定物体上的过程
      - 而指定的图片可以是一维，二维，或者三维的，其中，自然是二维图片最为常见
    - 像素着色阶段的主要目的是计算所有需逐像素操作的过程
  - 融合
    - 主要任务是合成当前储存于缓冲器中像素着色阶段产生的片段颜色
    - 每个像素的信息都储存在颜色缓冲器中，而颜色缓冲器是一个颜色的矩阵
      - 每种颜色包含红、绿、蓝三个分量
    - 运行该阶段的GPU子单元并非完全可编程的，但其高度可配置，可支持多种特效

    - 这个阶段还负责可见性问题的处理
      - 当绘制完整场景的时候，颜色缓冲器还包含从相机视点处可以观察到的场景图元
      - 大多数图形硬件是通过Z缓冲（也称深度缓冲器）算法来实现的
        - Z缓冲算法非常简单，具有O(n)复杂度（n是需要绘制的像素数量）
          - 只要对每个图元计算出相应的像素z值，就可以使用这种方法，大概内容是：

          - Z缓冲器器和颜色缓冲器形状大小一样，每个像素都存储着一个z值，这个z值是从相机到最近图元之间的距离
          - 每次将一个图元绘制为相应像素时，需要计算像素位置处图元的z值，并与同一像素处的z缓冲器内容进行比较
          - 如果新计算出的z值，远远小于z缓冲器中的z值，那么说明即将绘制的图元与相机的距离比原来距离相机最近的图元还要近
          - 这样，像素的z值和颜色就由当前图元对应的值和颜色进行更新
          - 反之，若计算出的z值远远大于z缓冲器中的z值，那么z缓冲器和颜色缓冲器中的值就无需改变

    - 颜色缓冲器用来存储颜色，z缓冲器用来存储每个像素的z值
    - 还有其他缓冲器可以用来过滤和捕获片段信息
      - 比如alpha通道（alphachannel）和颜色缓冲器联系在一起可以存储一个与每个像素相关的不透明值
        - 可选alpha测试可在，深度测试执行前在传入片段上运行
        - 片段的alpha值与参考值作某些特定的测试（如等于，大于等）
          - 如果片断未能通过测试，它将不再进行进一步的处理
        - alpha测试经常用于，不影响深度缓存的全透明片段的处理
      - 模板缓冲器（stencilbuffer）是用于记录所呈现图元位置的离屏缓存
        - 每个像素通常与占用8个位 unit8
        - 图元可使用各种方法渲染到模板缓冲器中，而缓冲器中的内容可以控制颜色缓存和Z缓存的渲染
          - 举个例子，假设在模版缓冲器中绘制出了一个实心圆形
            - 那么可以使用一系列操作符来将后续的图元仅在圆形所出现的像素处绘制，类似一个mask的操作
          - 模板缓冲器是制作特效的强大工具
            - 而在管线末端的所有这些功能都叫做光栅操作（ROP）或混合操作（blend operations）
      - 帧缓冲器（framebuffer）通常包含一个系统所具有的所有缓冲器
        - 但有时也可以认为是颜色缓冲器和z缓冲器的组合
      - 累计缓冲器（accumulationbuffer），是1990年，Haeberli和Akeley提出的一种缓冲器
        - 是对帧缓冲器的补充。这个缓冲器可以用一组操作符对图像进行累积
        - 例如，为了产生运动模糊（motionblur.，可以对一系列物体运动的图像进行累积和平均
          - 此外，其他的一些可产生的效果包括景深depth of field，反走样antialiasing和软阴影

    - 当图元通过光栅化阶段之后，从相机视点处看到的东西就可以在荧幕上显示出来
      - 为了避免观察者体验到对图元进行处理并发送到屏幕的过程图形系统一般使用了双缓冲doublebuffering   
        - 这意味着屏幕绘制是在一个后置缓冲器（backbuffer）中以离屏的方式进行的
        - 一旦屏幕已在后置缓冲器中绘制，后置缓冲器中的内容就不断与已经在屏幕上显示过的前置缓冲器中的内容进行交换，只有当不影响显示的时候，才进行交换 SwapChain

## GPU渲染管线与可编程着色器
# GPU管线 概述
  - 第一个包含顶点处理，面向消费者的图形芯片（NVIDIA GeForce256）发布于1999年
    - 且NVIDIA提出了图形处理单元（Graphics Processing Unit，GPU）这一术语
      - 将GeForce256和之前的只能进行光栅化处理的图形芯片相区分。
      - 在接下来的几年中，GPU从可配置的固定功能管线演变到了支持高度可编程的管线。
      - 直到如今，各种可编程着色器依然是控制GPU的主要手段。
      - 为了提高效率，GPU管线的一部分仍然保持着可配置
        - 但不是可编程的，但大趋势依然是朝着可编程和更具灵活性的方向在发展。

  - GPU实现了第二章中描述的几何和光栅化概念管线阶段
    - 其被分为一些不同程度的可配置性和可编程性的硬件阶段

  - GPU实现的渲染管线和第二章中描述的渲染管线的功能阶段在结构上略有不同

  -  顶点着色器（The Vertex Shader）是完全可编程的阶段
    - 顶点着色器可以对每个顶点进行诸如变换和变形在内的很多操作，提供了修改/创建/忽略顶点相关属性的功能，这些顶点属性包括颜色、法线、纹理坐标和位置。顶点着色器的必须完成的任务是将顶点从模型空间转换到齐次裁剪空间。

  -  几何着色器（The Geometry Shader）位于顶点着色器之后，允许GPU高效地创建和销毁几何图元
    - 几何着色器是可选的，完全可编程的阶段，主要对图元（点、线、三角形）的顶点进行操作。
    - 几何着色器接收顶点着色器的输出作为输入，通过高效的几何运算，将数据输出，数据随后经过几何阶段和光栅化阶段的其他处理后，会发送给片段着色器

  -  像素着色器（Pixel Shader，Direct3D中的叫法）常常又称为片断着色器，片元着色器Fragment Shader是完全可编程的阶段，主要作用是进行像素的处理，让复杂的着色方程在每一个像素上执行。
  -  裁剪（Clipping）属于可配置的功能阶段，在此阶段可选运行的裁剪方式，以及添加自定义的裁剪面。
  -  屏幕映射（Screen Mapping）、三角形设置（Triangle Setup）和三角形遍历（Triangle Traversal）阶段是固定功能阶段
  -  合并阶段（The Merger Stage）处于完全可编程和固定功能之间，尽管不能编程，但是高度可配置
    - 其除了进行合并操作，还分管颜色修改（Color Modifying），Z缓冲（Z-buffer），混合（Blend），模板（Stencil）和相关缓存的处理

  - GPU管线已经远离硬编码的运算操作，而朝着提高灵活性和控制性改进
#  可编程着色模型
  - 现代着色阶段（比如支持shader model 4.0，DirectX 10以及之后）使用了通用着色核心（common-shader core），这就表明顶点，片段，几何着色器共享一套编程模型
  - 早期的着色模型可以用汇编语言直接编程，但DX10之后，汇编就只在调试输出阶段可见，改用高级着色语言
  - 目前的着色语言都是C-like的着色语言，比如HLSL,CG和GLSL，其被编译成独立于机器的汇编语言，也称为中间语言（IL）。
    - 这些汇编语言在单独的阶段，通常是在驱动中，被转化成实际的机器语言
    - 这样的安排可以兼容不同的硬件实现。
    - 这些汇编语言可以被看做是定义一个作为着色语言编译器的虚拟机
    - 这个虚拟机是一个处理多种类型寄存器和数据源、预编了一系列指令的处理器
  - 着色语言虚拟机可以理解为一个处理多种类型寄存器和数据源、预编了一系列指令的处理器
    - 考虑到很多图形操作都使用短矢量（最高四位），处理器拥有4路SIMD（single-instruction multiple-data，单指令多数据）兼容性
    - 每个寄存器包含四个独立的值。32位单精度浮点的标量和矢量是其基本数据类型；也随后支持32位整型。
    - 浮点矢量通常包含数据如位置（xyzw），法线，矩阵行，颜色（rgba），或者纹理坐标（uvwq）
    - 而整型通常用来表示，计数器，索引，或者位掩码。也支持综合数据类型比如结构体，数组，和矩阵
    - 而为了便于使用向量，向量操作如调和（swizzling，也就是向量分量的重新排序或复制），和屏蔽（masking，只使用指定的矢量元素），也能够支持


图3.2 DX 10下的通用Shader核心虚拟机架构以及寄存器布局。每个资源旁边显示最大可用编号。其中，用两个斜杠分开的三个数值，分别是顶点，几何、像素着色器对应的可用最大值。

  - 一个绘制调用（也就是喜闻乐见的Draw Call）会调用图形API来绘制一系列的图元，会驱使图形管线的运行
  - 每个可编程着色阶段拥有两种类型的输入：
    - uniform输入，在一个draw call中保持不变的值（但在不同draw call之间可以更改）
    - varying输入，shader里对每个顶点和像素的处理都不同的值
      - 纹理是特殊类型的uniform输入，曾经一直是一张应用到表面的彩色图片
        - 但现在可以认为是存储着大量数据的数组。

  - 在现代GPU上 ，图形运算中常见的运算操作执行速度非常快。
    - 通常情况下，最快的操作是标量和向量的乘法和加法，以及他们的组合
      - 如乘加运算（multiply-add）和点乘 （dot-product）运算
      - 其他操作，比如倒数（reciprocal）, 平方根（square root），正弦（sine），余弦（cosine），指数（exponentiation）、对数（logarithm）运算，往往会稍微更加昂贵，但依然相当快捷
      - 纹理操作非常高效，但他们的性能可能受到诸如等待检索结果的时间等因素的限制
  - 着色语言表示出了大多数场常见的操作（比如加法和乘法通过运算符+和\*来表示）
    - 其余的操作用固有的函数，比如atan() , dot() , log(),等
    - 更复杂的操作也存在内建函数，比如矢量归一化（vector normalization）、反射（reflection）、叉乘（cross products）、矩阵的转置（matrix transpose）和行列式（determinant）等

  - 流控制（flow control）是指使用分支指令来改变代码执行流程的操作
    - 这些指令用于实现高级语言结构，如“if”和“case”语句，以及各种类型的循环
    - Shader支持两种类型的流控制
      - 静态流控制（Static flow control）是基于统一输入的值的
        - 这意味着代码的流在调用时是恒定的
        - 静态流控制的主要好处是允许在不同的情况下使用相同的着色器（例如，不同数量的光源）
      - 动态流控制（Dynamic flow control）基于不同的输入值。
        - 但动态流控制远比静态流量控制更强大但同时也需更高的开销，特别是在调用shader之间，代码流不规律改变的时候
        - 评估一个shader的性能，是评估其在一段时间内处理顶点或像素的个数
        - 如果流对某些元素选择“if”分支，而对其他元素选择“else”分支，这两个分支必须对所有元素进行评估（并且每个元素的未使用分支将被丢弃）

  - Shader程序可以在程序加载或运行时离线编译
    - 和任何编译器一样，有生成不同输出文件和使用不同优化级别的选项。
    - 一个编译过的Shader作为字符串或者文本来存储，并通过驱动程序传递给GPU
# 顶点着色器 Vertext Shader
  - 它是流水线上的第一个阶段，可选是在GPU还是CPU上实现
    - 而在CPU上实现的话，需将CPU中的输出数据发送到GPU进行光栅化
    - 目前几乎所有的GPU都支持顶点着色
  - 顶点着色器是完全可编程的阶段，是专门处理传入的顶点信息的着色器
  - 顶点着色器可以对每个顶点进行诸如变换和变形在内的很多操作
  - 顶点着色器一般不处理附加信息， 顶点着色器提供了修改，创建，或者忽略与每个 多边形顶点 相关的值
      - 例如其颜色，法线，纹理坐标和位置。
    - 顶点着色器程序将顶点从模型空间（ModelSpace）变换到齐次裁剪空间（Homogeneous ClipSpace）
      - 一个顶点着色器至少且必须输出此变换位置
  - 顶点着色阶段之前发生了一些数据操作
    - 比如在DirectX中叫做输入装配（InputAssembler）的阶段
      - 会将一些数据流组织在一起，以形成顶点和基元的集合，发送到管线

  - 顶点着色器本身通用核心虚拟机（Common-Shader Core Virtual  Machine）非常相似
      - 传入的每个顶点由顶点着色器程序处理，然后输出一些在三角形或直线上进行插值后获得的值
      - 顶点着色器既不能创建也不能消除顶点，并且由一个顶点生成的结果不能传递到另一个顶点。
      - 由于每个顶点都被独立处理，所以GPU上的任何数量的着色器处理器都可以并行地应用到传入的顶点流上。

  - 顶点着色器的输出可以以许多不同的方式来使用，通常是用于每个实例三角形的生成和光栅化
      - 然后各个像素片段被发送到像素着色器，以便继续处理
      - 而在ShaderModel 4.0中，数据也可以发送到几何着色器（Geometry Shader）或输出流（Streamed
    Output）或同时发动到像素着色器和几何着色器两者中
# 几何着色器 The Geometry Shader
  - 几何着色器（Geometry Shader）是顶点和片段着色器之间一个可选的着色器
  - 几何着色器的输入是单个对象及对象相关的顶点，而对象通常是网格中的三角形，线段或简单的点
    - 另外，扩展的图元可以由几何着色器定义和处理

  - 几何着色器程序的输入是一个单独的类型：点，线段，三角形
    - 两个最右边的图元，包括与线和三角形对象相邻的顶点也可被使用。

  - 几何着色器可以改变新传递进来的图元的拓扑结构，且几何着色器可以接收任何拓扑类型的图元，但是只能输出点、折线（line  strip）和三角形条（triangle strips）

  - 几何着色器需要图元作为输入，在处理过程中他可以将这个图元整个丢弃或者输出一个或更多的图元（也就是说它可以产生比它得到的更多或更少的顶点）。
    - 这个能力被叫做几何增长（growing geometry）
    - 如上所述，几何着色器输出的形式只能是点，折线和三角形条。

  - 当我们未添加几何着色器时，默认的行为是将输入的三角形直接输出。
    - 我们添加了几何着色器之后，可以在几何着色器中修改输出的图形，我们可以输出我们想要输出的任何图形



    图
    3.7.一些几何着色器的应用。左图，使用几何着色器实现元球的等值面曲面细分（metaball
    isosurface
    tessellation）。中图，使用了几何着色器和流输出进行线段细分的分形（fractal
    subdivision of line
    segments）。右图，使用顶点和几何着色器的流输出进行布料模拟。（图片来自NVIDIA SDK
    10的示例）

# 流输出 Stream Output
  - GPU的管线的标准使用方式是发送数据到顶点着色器，然后对所得到的三角形进行光栅化处理，并在像素着色器中处理它们。
  - 数据总是通过管线传递，无法访问中间结果
    - 流输出的想法在Shader Model4.0中被引入
    - 在顶点着色器（以及可选的几何着色器中）处理顶点之后，除了将数据发送到光栅化阶段之外
      - 也可以输出到流，也就是一个有序数组中进行处理
    - 事实上，可以完全关掉光栅化，然后管线纯粹作为非图形流处理器来使用  
      - 以这种方式处理的数据可以通过管线回传，从而允许迭代处理
      - 这种操作特别适用于模拟流动的水或其他粒子特效

# 图形渲染与视觉外观
-
# 纹理贴图及相关技术
-
# 高级着色：BRDF及相关技术
-
# 延迟渲染
-
#  全局光照:光线追踪、路径追踪与GI
-

# 基于图像的渲染技术总结
# 非真实感渲染(NPR)
# 渲染加速算法
# 渲染管线优化方法
