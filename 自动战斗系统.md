# 自动战斗
- 自动战斗管理器
  - 打开
  - 关闭
- 检测范围内目标
- 检测到
  - 移动到目标
  - 释放攻击或者技能
    - 计算释放选择
- 加大范围
- GetViewTarget
- LineOfSightTo

- 产生一个新的AIController，并拥有Player的Pawn
- PlayerController持有对AIController的引用
  - 应该具有被设置为服务器的复制事件
- 只允许将其调用为requestMoveTo
- 如果要移动AI，您应该始终在服务器上执行此操作
- 这就是UE4 AI的设置方式。

# 自动战斗2
- 玩家状态
  - 闲置
    - 更新附近怪物信息
  - 追捕
    - 追捕怪物
    - 移动逻辑
      - 更新距离
      -
  - 战斗
    - 攻击当前战斗中的怪物
      - 如果怪物死亡，转换状态到追捕
      - 技能使用优先级

# Controller Possess
- 检测是否为服务器执行
- 检测Pawn
- 取消切换控制的Pawn
  - 先取消自己
  - 在取消别人
- 执行拥有操作
  - Pawn->PossessedBy
  - SetPawn（Pawn）
- 设定旋转
- Restart

# SetPawn
- 取消PawnTick依赖
- 取代Pawn
- AttachToPawn
- 增加新的依赖

# AttachToPawn
- 判断条件
- 设置Controller到Pawn的RootComponent

# Controller
- Possess UnPossess
- GetNavAgentLocation
- IsFollowingAPath
- PlayerState*
- SceneComponent*

- Controller应该是一个具体执行类
- Pawn和HUD应该是用来显示的  MVC架构

# UPlayer
- SwitchController(APlayerController* )

# ULocalPlayer
- 本地玩家
- ULocalPlayer比UPlayer多了Viewport相关的配置
- UE在初始化GameInstance的时候，
  - 创建出一个GameViewportClient
  - 然后在内部再转发到GameInstance的CreateLocalPlayer
    - 如果是在Server模式 执行 SpawnPlayerActor  
      - SpawnPlayerActor实现了创建出PlayerController的功能
    - 如果是Client
      - 先发送JoinSplit消息到服务器，在载入服务器上的Map之后，再为LocalPlayer创建出PlayerController
# PlayerController
- UPlayer关联
  - 一个UPlayer可以是本地的LocalPlayer，也可以是一个网络控制UNetConnection
# - SetPlayer
      - 先Cast成LocalPlayer
      - 成功 为本地玩家
        - 执行 SetAsLocalPlayerController
        - InitOnlineSession
        - InitInputSystem
      - 失败 Cast为NetConnection
      - PlayerController只有在SetPlayer之后，才可以开始正常工作


- Voice，也是为了方便网络中语音聊天的一些控制函数
- CameraManager
- HUD
- Input
- Pawn ||  SpectatorPawn
- Level的切换

# UNetConnection
- TArray<UChildConnection*> Childen
- UNetDriver*
- TArray<UChannel*> OpenChannels
- TArray<Actor* > SentTemporaries
# IpConnection
- 包含Socket

# UNetDriver
- TArray<UNetConnection* > Client
- UNetConnection* Server
# AIController
- Navigation
- Task
- BrainComponent
