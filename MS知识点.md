## MS知识点


* C++语法

* 容器基本操作
  - 参照UEContainer
# 排序
  - 桶
    - 桶排序假设待排序的一组数均匀独立的分布在一个范围中，并将这一范围划分成几个子范围（桶）
  - 基数排序
  - 计数排序
    - 在排序的时候就知道他的位置，那不就是扫描一遍，把他放入他应该的位置不就可以了。 要知道他的位置，我们只需要知道有多少不大于他不就可以了
  - 快速排序
    - 快速排序的每一轮就是将这一轮的基准数归位，直到所有的数都归为为止，排序结束（类似冒泡）
  - 堆排序
    - 堆排序借助了堆这个数据结构，堆类似二叉树，又具有堆积的性质（子节点的关键值总小于（大于）父节点）
  - 归并排序
    - 可以将数组分成二组。依次类推，当分出来的小组只有一个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的二个小组就可以了
      - 这样通过先递归的分解数列，再合并数列就完成了归并排序
  - 插入排序 选择排序  冒泡排序
# 字符串
  - 旋转字符串
    - 暴力移位法
    - 三步反转法
      - 将原字符串分为两个部分 即X:abc，Y:def
      - 将X反转，X->X^T，即得：abc->cba；将Y反转，Y->Y^T，即得：def->fed
      - 反转上述步骤得到的结果字符串X^TY^T，即反转字符串cbafed的两部分（cba和fed）给予反转
        - cbafed得到defabc，形式化表示为(X^TY^T)^T=YX，这就实现了整个反转
  - 字符串包含
    - 针对string2中每一个字符，逐个与string1中每个字符比较
    - 对这两个字符串的字母进行排序，然后再同时对两个字串依次轮询
    - 按照从小到大的顺序，用26个素数分别与字符'A'到'Z'一一对应
      - 遍历长字符串，求得每个字符对应素数的乘积。
        - 遍历短字符串，判断乘积能否被短字符串中的字符对应的素数整除
  - 字符串转换成整数
    - 从左至右扫描字符串，把之前得到的数字乘以10，再加上当前字符表示的数字
  - 回文判断
    - 从字符串头尾开始向中间扫描字串，如果所有字符都一样，那么这个字串就是一个回文
    - 我们可以先从中间开始、然后向两边扩展查看字符是否相等
  - 最长回文子串
    - 可以枚举中心位置，然后再在该位置上用扩展法，记录并更新得到的最长的回文长度
      - 枚举中心位置中，我们需要特别考虑字符串的长度是奇数还是偶数
      - 所以导致我们在编写代码实现的时候要把奇数和偶数的情况分开编写
    - Manacher算法
  - 字符串的全排列
    - 从集合中依次选出每一个元素，作为排列的第一个元素，然后对剩余的元素进行全排列，如此递归处理，从而得到所有元素的全排列
    - STL中的next_permutation算法
# 数组
  - 寻找最小的 k 个数
    - 先对这个序列从小到大排序，然后输出前面的最小的k个数
    - 遍历n个数，把最先遍历到的k个数存入到大小为k的数组中，假设它们即是最小的k个数；
      -对这k个数，利用选择或交换排序找到这k个元素中的最大值kmax（找最大值需要遍历这k个数，时间复杂度为O（k））；
        - 继续遍历剩余n-k个数。假设每一次遍历到的新的元素的值为x，把x与kmax比较：
          - 如果x < kmax ，用x替换kmax，并回到第二步重新找出k个元素的数组中最大元素kmax‘；如果x >= kmax，则继续遍历不更新数组
    - 用容量为k的最大堆存储最先遍历到的k个数，同样假设它们即是最小的k个数；
      - 堆中元素是有序的，令k1<k2<...<kmax（kmax设为最大堆中的最大元素）
        - 遍历剩余n-k个数。假设每一次遍历到的新的元素的值为x，把x与堆顶元素kmax比较：如果x < kmax，用x替换kmax，然后更新堆（用时logk）；否则不更新堆
  - 寻找和为定值的两个数
    - 第一个数组以一指针i 从数组最左端开始向右扫描，第二个数组以一指针j 从数组最右端开始向左扫描
      - 如果第一个数组出现了和第二个数组一样的数，即a[* i]=a[* j]，就找出这俩个数来了
        - 如上，i，j最终在第一个，和第二个序列中找到了相同的数4和11，所以符合条件的两个数，即为4+11=15
    - 即给定一个数字，根据hash映射查找另一个数字是否也在数组中，只需用O(1)的时间，前提是经过O(N)时间的预处理，和用O(N)的空间构造hash表
    - 如果数组是无序的，先排序(N log N)，然后用两个指针i，j，各自指向数组的首尾两端，令i=0，j=n-1，然后i++，j--，逐次判断a[i]+a[j]?=sum
  - 寻找和为定值的多个数
    - 注意到取n，和不取n个区别即可，考虑是否取第n个数的策略，可以转化为一个只和前n-1个数相关的问题。
      - 如果取第n个数，那么问题就转化为“取前n-1个数使得它们的和为sum-n”，对应的代码语句就是sumOfkNumber(sum - n, n - 1)；
      - 如果不取第n个数，那么问题就转化为“取前n-1个数使得他们的和为sum”，对应的代码语句为sumOfkNumber(sum, n - 1)。
    - 这个问题属于子集和问题（也是背包问题）。本程序采用回溯法+剪枝，其中X数组是解向量，t=∑(1,..,k-1)Wi*Xi, r=∑(k,..,n)Wi
      - 若t+Wk+W(k+1)<=M,则Xk=true，递归左儿子(X1,X2,..,X(k-1),1)；否则剪枝；
      - 若t+r-Wk>=M && t+W(k+1)<=M,则置Xk=0，递归右儿子(X1,X2,..,X(k-1),0)；否则剪枝
  - 最大连续子数组和
    - 求一个数组的最大子数组和，我想最直观最野蛮的办法便是，三个for循环三层遍历，求出数组中每一个子数组的和，最终求出这些子数组的最大的一个值。 令currSum[i, …, j]为数组A中第i个元素到第j个元素的和（其中0 <= i <= j < n），maxSum为最终求到的最大连续子数组的和
    - 事实上，当我们令currSum为当前最大子数组的和，maxSum为最后要返回的最大子数组的和，当我们往后扫描时，
      - 对第j+1个元素有两种选择：要么放入前面找到的子数组，要么做为新子数组的第一个元素；
      - 如果currSum加上当前元素a[j]后不小于a[j]，则令currSum加上a[j]，否则currSum重新赋值，置为下一个元素，即currSum = a[j]。
      - 同时，当currSum > maxSum，则更新maxSum = currSum，否则保持原值，不更新
  - 跳台阶
    - 首先考虑最简单的情况。如果只有1级台阶，那显然只有一种跳法。如果有2级台阶，那就有两种跳的方法了：一种是分两次跳，每次跳1级；另外一种就是一次跳2级
    - 解法一用的递归的方法有许多重复计算的工作，事实上，我们可以从后往前推，一步步利用之前计算的结果递推。
      - 初始化时，dp[0]=dp[1]=1，然后递推计算即可：dp[n] = dp[n-1] + dp[n-2]
  - 奇偶排序
    - 借鉴partition的实现一，我们可以考虑维护两个指针，一个指针指向数组的第一个数字，我们称之为头指针，向右移动；一个指针指向最后一个数字，称之为尾指针，向左移动。
      - 这样，两个指针分别从数组的头部和尾部向数组的中间移动，如果第一个指针指向的数字是偶数而第二个指针指向的数字是奇数，我们就交换这两个数字
    - 借鉴partition的上述实现，我们也可以维护两个指针i和j，一个指针指向数组的第一个数的前一个位置，我们称之为后指针i，向右移动；一个指针指向数组第一个数，称之为前指针j，也向右移动，且前指针j先向右移动。如果前指针j指向的数字是奇数，则令i指针向右移动一位，然后交换i和j指针所各自指向的数字
  - 荷兰国旗
    - 通过前面的分析得知，这个问题类似快排中partition过程，只是需要用到三个指针：一个前指针begin，一个中指针current，一个后指针end，current指针遍历整个数组序列，当
      - current指针所指元素为0时，与begin指针所指的元素交换，而后current++，begin++ ；
      - current指针所指元素为1时，不做任何交换（即球不动），而后current++ ；
      - current指针所指元素为2时，与end指针所指的元素交换，而后，current指针不动，end--
  - 矩阵相乘
    - Strassen算法
  - 完美洗牌
    - pefect_shuffle算法
    - cycle_leader算法
# 树
  - 红黑树
  - B树
  - 二分查找树
  - 最近公共祖先LCA
    - Tarjan算法
# 查找匹配
  - 有序数组的查找
    - 要准确实现二分查找，首先要把握下面几个要点：
    - 关于right的赋值
      - right = n-1 => while(left <= right) => right = middle-1;
      - right = n => while(left < right) => right = middle;
      - middle的计算不能写在while循环外，否则无法得到更新
  - 行列递增矩阵的查找
    - 首先直接定位到最右上角的元素，再配以二分查找，比要找的数（6）大就往左走，比要找数（6）的小就往下走，直到找到要找的数字（6）为止，这个方法的时间复杂度O（m+n）
    - 杨氏矩阵查找
  - 出现次数超过一半的数字
    - 如果无序，那么我们是不是可以先把数组中所有这些数字先进行排序（至于排序方法可选取最常用的快速排序）。排完序后，直接遍历，在遍历整个数组的同时统计每个数字的出现次数，然后把那个出现次数超过一半的数字直接输出，题目便解答完成了。总的时间复杂度为O(nlogn + n)
    - 既要缩小总的时间复杂度，那么可以用查找时间复杂度为O(1)的hash表，即以空间换时间。哈希表的键值（Key）为数组中的数字，值（Value）为该数字对应的次数。然后直接遍历整个hash表，找出每一个数字在对应的位置处出现的次数，输出那个出现次数超过一半的数字即可
    - 每次删除两个不同的数（不管是不是我们要查找的那个出现次数超过一半的数字），那么，在剩下的数中，我们要查找的数（出现次数超过一半）出现的次数仍然超过总数的一半。通过不断重复这个过程，不断排除掉其它的数，最终找到那个出现次数超过一半的数字。这个方法，免去了排序，也避免了空间O(n)的开销，总得说来，时间复杂度只有O(n)，空间复杂度为O(1)，貌似不失为最佳方法
# 动规
  - 最大连续乘积子串
    - 两个for循环直接轮询
    - 接利用动态规划来求解，考虑到可能存在负数的情况，我们用maxend来表示以a[i]结尾的最大连续子串的乘积值，用minend表示以a[i]结尾的最小的子串的乘积值，那么状态转移方程为：
      - maxend = max(max(maxend * a[i], minend * a[i]), a[i]);
      - minend = min(min(maxend * a[i], minend * a[i]), a[i]);
      - 初始状态为maxend = minend = a[0]
  - 字符串编辑距离
  - 格子取数
  - 交替字符串
- RGB操作
  - α*A+(1-α)* B
