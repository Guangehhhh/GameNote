## MPL
- 具体来说 C++ 模板可以做以下事情：编译期数值计算、类型计算、代码计算（如循环展开），其中数值计算实际不太有意义
  - 而类型计算和代码计算可以使得代码更加通用，更加易用，性能更好（也更难阅读，更难调试，有时也会有代码膨胀问题）
  - 编译期计算在编译过程中的位置请见下图（取自文献[10]），可以看到关键是模板的机制在编译具体代码（模板实例）前执行
- C++ 模板是函数式编程（functional programming），它的主要特点是：函数调用不产生任何副作用（没有可变的存储）
  - 用递归形式实现循环结构的功能
  - C++ 模板的特例化提供了条件判断能力，而模板递归嵌套提供了循环的能力，这两点使得其具有和普通语言一样通用的能力
- 从编程形式来看，模板的“<>”中的模板参数相当于函数调用的输入参数，模板中的 typedef 或 static const 或 enum 定义函数返回值（类型或数值，数值仅支持整型，如果需要可以通过编码计算浮点数），代码计算是通过类型计算进而选择类型的函数实现的（C++ 属于静态类型语言，编译器对类型的操控能力很强）
# 模板参数
- 类型参数（type template parameter），用 typename 或 class 标记；
- 非类型参数（non-type template parameter）可以是：整数及枚举类型、对象或函数的指针、对象或函数的引用、对象的成员指针，非类型参数是模板实例的常量；
- 模板型参数（template template parameter），如“template<typename T, template<typename> class A> someclass {};”；
- 模板参数可以有默认值（函数模板参数默认 是从 C++11 开始支持）；
- 函数模板的和函数参数类型有关的模板参数可以自动推导，类模板参数不存在推导机制；
- C++11 引入变长模板参数
# 模板特化
- 所谓模板特例化即对于通例中的某种或某些情况做单独专门实现
  - 最简单的情况是对每个模板参数指定一个具体值，这成为完全特例化（full specialization）
  - 另外，可以限制模板参数在一个范围取值或满足一定关系等，这称为部分特例化（partial specialization）
  - 用数学上集合的概念，通例模板参数所有可取的值组合构成全集U
  - 完全特例化对U中某个元素进行专门定义，部分特例化对U的某个真子集进行专门定义

- 在定义模板特例之前必须已经有模板通例（primary template）的声明；
  - 模板特例并不要求一定与通例有相同的接口，但为了方便使用（体会特例的语义）一般都相同；
  - 匹配规则，在模板实例化时如果有模板通例、特例加起来多个模板版本可以匹配，则依据如下规则：
    - 对版本AB，如果 A 的模板参数取值集合是B的真子集，则优先匹配 A
      - 如果 AB 的模板参数取值集合是“交叉”关系（AB 交集不为空，且不为包含关系）
        - 则发生编译错误，对于函数模板，用函数重载分辨（overload resolution）规则和上述规则结合并优先匹配非模板函数
- 同一个模板（模板名及其参数类型列表构成的模板签名（template signature）相同，函数模板可以重载，类模板不存在重载）
  - 且指定的模板实参等价（类型参数是等价类型，非类型参数值相同）
# 模板实例化
- 在编译或链接时生成函数模板或类模板的具体实例源代码
  - 即用使用模板时的实参类型替换模板类型参数（还有非类型参数和模板型参数）；
- 隐式实例化（implicit instantiation）：当使用实例化的模板时自动地在当前代码单元之前插入模板的实例化代码，模板的成员函数一直到引用时才被实例化；
- 显式实例化（explicit instantiation）：直接声明模板实例化，模板所有成员立即都被实例化；
- 实例化也是一种特例化，被称为实例化的特例（instantiated (or generated) specialization）。

# 模板的编译和链接
- 包含模板编译模式：编译器生成每个编译单元中遇到的所有的模板实例，并存放在相应的目标文件中；链接器合并等价的模板实例，生成可执行文件，要求实例化时模板定义可见，不能使用系统链接器；
分离模板编译模式（使用 export 关键字）：不重复生成模板实例，编译器设计要求高，可以使用系统链接器；
包含编译模式是主流，C++11 已经弃用 export 关键字（对模板引入 extern 新用法），一般将模板的全部实现代码放在同一个头文件中并在用到模板的地方用 #include 包含头文件，以防止出现实例不一致（如下面紧接着例子）；
# C++11 关于模板的新特性
- “>>” 根据上下文自动识别正确语义；
- 函数模板参数默认值；
- 变长模板参数（扩展 sizeof...() 获取参数个数）；
- 模板别名（扩展 using 关键字）；
- 外部模板实例（拓展 extern 关键字），弃用 export template
# 循环展开
# 表达式模板
#
