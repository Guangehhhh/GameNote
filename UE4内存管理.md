# 内存管理
- 有三种基本的内存分配和释放方法：
  - 使用GMalloc指针
    - 这种方法是获得全局的分配器，分配器的使用依赖于GCreateMalloc()函数。
  - FMemory函数
    - 有静态函数比如：Malloc()，Realloc()，Free()
    - 他们也是使用GMalloc来申请内存，但是在此之前，它会在每次allocation, reallocation或free之前
      - 检查是否定义GMalloc
      - 若GMalloc 是空，就调用GCreateMalloc()
  - 全局的的New和delete操作
    - 缺省情况下，只在模块的ModuleBoilerplate.h 的文件中定义
      - 也就是说，很多调用new和delete的操作不在虚幻4的内存系统中管理
      - 重载操作实际上调用的是FMemory函数
# 内存分配方式
- 在C++中内存分为5个区
  - 堆：堆是操作系统中的术语，是操作系统所维护的一块特殊内存
    - 用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。
  - 栈：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放
    - 栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
  - 自由存储区：自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。
  - 常量存储区：这是一块比较特殊的存储区，他们里面存放的是常量(const)，不允许修改
  - 全局/静态存储区：这块内存是在程序编译的时候就已经分配好的，在程序整个运行期间都存在。
    - 例如全局变量，静态变量。
# 内存池
- large_pool
  - 整个内存分配的最底层，都是基于large_pool的大块内存分配池，类似于linux的基于page的分配管理
  - 不过有所不同的是，large_pool并没有像linux那样使用buddy算法进行(2^N)page进行分配
  - 这样如果需要2.1m的内存，需要分配4m的内存块，这样力度太大，非常浪费。
  - 因此large_pool内部采用N*page的基于page_size为最小粒度进行分配，因此每次分配顶多浪费不到一页的空间。
  - 如果需要的内存不到整页，剩下的内存也会一并返回给上层
  - 如果上层需要（比如small_pool），可以充分利用这多余的部分内存空间，使得内存利用率达到最优化。
  - 根据tb_init实际传入的参数需求，large_pool有两种模式：
- 直接使用系统内存分配接口将进行大块内存的分配，并用双链维护，这种比较简单
   - 在一大块连续内存上进行统一管理，实现内存分配。
   - 具体使用哪种方式，根据应用需求，一般的应用只需要使用方式1就行了，
   - 这个时候tb_init传tb_null就行了，如果是嵌入式应用，需要管理有限的一块内存空间
   - 这个时候可以使用方式2， tb_init传入指定内存空间地址和大小

- small_pool
- fixed_pool
- string_pool
# C++ 内存管理
- 通常我们习惯直接使用new、malloc等API申请分配内存，这样做的缺点在于：由于所申请内存块的大小不定
  - 当频繁使用时会造成大量的内存碎片并进而降低性能
  - C/C++的内存分配(通过malloc或new)可能需要花费很多时
  - 更糟糕的是，随着时间的流逝，内存(memory)将形成碎片
  - 所以一个应用程序的运行会越来越慢当它运行了很长时间和/或执行了很多的内存分配(释放)操作的时候
  - 特别是，你经常申请很小的一块内存，堆(heap)会变成碎片的
  - 这就是为什么我们经常在运行自己的C/C++程序时一开始还好好的，可是越到后面速度越慢，最后甚至直接罢工了

- 对于以上，一个可行的的解决方案就是设计一个自己的内存分配策略，也即设计一个你自己的内存池
  - 内存池(Memory Pool)是一种内存分配方式。
  - 内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用
  - 当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存
  - 这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升
  - 在启动的时候，一个”内存池”(Memory Pool)分配一块很大的内存，并将会将这个大块(block)分成较小的块(smaller chunks)
  - 每次你从内存池申请内存空间时，它会从先前已经分配的块(chunks)中得到，而不是从操作系统

- 最大的优势在于：
  - 非常少(几没有) 堆碎片
  - 比通常的内存申请/释放(比如通过malloc, new等)的方式快
  - 检查任何一个指针是否在内存池里
  - 写一个”堆转储(Heap-Dump)”到你的硬盘(对事后的调试非常有用)
  - 某种”内存泄漏检测(memory-leak detection)”：当你没有释放所有以前分配的内存时，内存池(Memory Pool)会抛出一个断言(assertion).
