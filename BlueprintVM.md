## VM
---
# 什么是虚拟机？？
- 系统虚拟机（如VirtualBox）提供一个可以运行完整操作系统的完整系统平台
- 程序虚拟机（如Java JVM）为运行单个计算机程序设计，这意謂它支持单个进程
  - 程序虚拟机，VM既然被称为"机器"，一般认为输入是满足某种指令集架构（instruction set architecture，ISA）的指令序列
    - 中间转换为目标ISA的指令序列并加以执行，输出为程序的执行结果的，就是VM
    - 源与目标ISA可以是同一种，这是所谓same-ISA VM
# 虚拟机实现分为哪种？？
  - 基于寄存器的虚拟机
  - 基于栈的虚拟机
    - 零地址意味着源与目标都是隐含参数，其实现依赖于一种常见的数据结构——没错，就是栈
    - 零地址形式的指令集一般就是通过"基于栈的架构"来实现的
      - 求值栈压入整型常量1、2。iadd指令则从求值栈顶弹出2个值，将值相加，然后把结果压回到栈顶
      - 因此在空间紧缺的环境中，零地址指令是种可取的设计
# 基于栈与基于寄存器结构的区别什么？？
- 保存临时值的位置不同
  - 基于栈：将临时值保存在求值栈上。
  - 基于寄存器：将临时值保存在寄存器中。
- 代码所占体积不同
  - 基于栈：代码紧凑，体积小，但所需要的代码条件多
  - 基于寄存器：代码相对大些，但所需要的代码条件少

# 栈帧是社么？？
- 栈帧也叫过程活动记录，是编译器用来实现过程/函数调用的一种数据结构
  - 从逻辑上讲，栈帧就是一个函数执行的环境：函数参数、函数的局部变量、函数执行完后返回到哪里等等
  - 在Stack.h中我们可以找到FFrame的定义，虽然它定义的是一个结构体，但是执行当前代码的逻辑是封装在这里面的
  - 它里面保存了当前执行的脚本函数，执行该脚本的UObject，当前代码的执行位置，局部变量，上一个栈帧，调用返回的参数（不是返回值），当前执行的原生函数等。而调用函数的返回值是放在了函数调用之前保存，调用结束后再恢复
    - uint8 * SaveCode = Stack.Code;
    - Stack.Code = SaveCode
# 字节码 EExprToken 是什么？？
- 虚拟机的字节码在Script.h文件中，因为是专用的脚本语言，所以它里面会有一些特殊的字节码，如代理相关的代码（EX_BindDelegate、EX_AddMulticastDelegate），赋值、无条件跳转指令、条件跳转指令、switch等
- 字节码对应函数
  - ScriptCore.cpp中查找定义，可以看到每个字节码对应的原生函数都在GNatives和GCasts里面
  - typedef void (UObject::* Native)( FFrame& TheStack, RESULT_DECL );
  - 这样它都会对每一个原生函数调用一下注册方法，通过IMPLEMENT_VM_FUNCTION和IMPLEMENT_CAST_FUNCTION宏实现
    - 它是定义了一个全局静态对象，这样就会在程序的main函数执行前就已经把函数放在数组中对应的位置了，这样在虚拟机执行时就可以直接调用到对应的原生函数了
# 蓝图虚拟机是如何实现的？？
- 前面我们已经简单得介绍了虚拟机的相关术语，接下来我们来具体讲解下虚幻4中蓝图虚拟机的实现
- Step()函数
  - 它的主要作用就是取出指令，然后在原生函数数组中找到对应的函数去执行
  - int32 B = * Code++;
  - (Context->* GNatives[B])(* this,RESULT_PARAM);
# C++和调用蓝图函数？？
- ProcessEvent
- ProcessEvent流程 看图
# 蓝图调用C++函数
- UHT会生成如上的代码，并且如果有参数的话，会调用P_GET_UBOOL等来获取对应的参数，如果有返回值的话也会将返回值赋值
