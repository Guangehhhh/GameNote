# 多线程

## 启动线程
-  std::thread my_thread(do_some_work)
- 使线程函数的功能齐全，将数据复制到线程中，而非复制到共享数据中
- 使用一个能访问局部变量的函数去创建线程是一个糟糕的主意

- 等待线程完成 join()
  - std::thread 实例需要使用join()
  - 调用join()的行为，还清理了线程相关的存储部分
  - catch(...){t.join(); // 1throw;}
  - ~thread_guard(){  if  (t.joinable() )    {t.join();  } }

- 后台运行线程 detach()
  - 这就意味着主线程不能与之产生直接交互
  - 不会等待这个线程结束
  - 如果线程分离，那么就不可能有 std::thread 对象能引用它
  - 分离线程的确在后台运行，所以分离线程不能被加入
  - 不过C++运行库保证，当线程退出时，相关资源的能够正确回收，后台线程的归属和控制C++运行库都会理
  - 从 std::thread 对象中分离线程(前提是有可进行分离的线程)
    - 不能对没有执行线程的 std::thread 对象使用detach(),也是join()的使用条件
    - 并且要用同样的方式进行检查
    - 当 std::thread 对象使用t.joinable()返回的是true，就可以使用t.detach()
- 向线程函数传递参数
  - std::string(buffer)构造函数之前就将字面值转化
  - std::thread 的构造函数无视函数期待的参数类型
    - std::ref 将参数转换成引用的形式
  - std::bind
    - 可以传递一个成员函数指针作为线程函数
    - 并提供一个合适的对象指针作为第一个参数


- 转移线程所有权
- std::move()"移动"是指
  - 原始对象中的数据转移给另一对象，而转移的这些数据就不再在原始对象中保存了
  -  std::unique_ptr 就是这样一种类型, 这种类型为动态分配的对象提供内存自动管理机制
  - 同一时间内，只允许一个 std::unique_ptr 实现指向一个给定对象
  - 并且当这个实现销毁时，指向的对象也将被删除
  - std::thread t(process_big_object,std::move(p))

  - std::thread t1(some_function);  //t1和执行线程已经没
  - std::thread t2=std::move(t1);
- std::mem_fn(&std::thread::join)

- 运行时决定线程数量
  - std::thread::hardware_concurrency()
    - 这个函数将返回能同时并发在一个程序中的线程数量   

- 识别线程
  - 线程标识类型是 std::thread::id ，可以通过两种方式进行检索
    - 可以通过调用 std::thread 对象的成员函数 get_id() 来直接获取
    - 如果 std::thread 对象没有与任何执行线程相关联
    -  get_id() 将返回 std::thread::type 默认构造值，这个值表示“没有线程”
    - std::thread::id 对象可以自由的拷贝和对比,因为标识符就可以复用


## 线程间共享数据
- 共享数据带来的问题
  - 当一个或多个线程要修改共享数据时，就会产生很多麻
  - 线程间潜在问题就是修改共享数据，致使不变量遭到破坏
- 条件竞争
  - 并发中竞争条件的形成，取决于一个以上线程的相对执行顺序
    - 每个线程都抢着完成自己的任务
- 当不变量遭到破坏时，才会产生条件竞争

- 避免恶性条件竞争
  - 最简单的办法就是对数据结构采用某种保护机制
    - 确保只有进行修改的线程才能看到不变量被破坏时的中间状态
  - 另一个选择是对数据结构和不变量的设计进行修改，修改完的结构必须能完成一系列不可分割的变化
    - 也就是保证每个不变量保持稳定的状态，这就是所谓的无锁编程(lock-freeprogramming)
  - 使用事务(transacting)的方式去处理数据结构的更新
    - 所需的一些数据和读取都存储在事务日志中，然后将之前的操作合为一步，再进行提交
- 使用互斥量保护共享数据
  - 保护共享数据结构的最基本的方式，是使用C++标准库提供的互斥量(mutex)
  - 将所有访问共享数据结构的代码都标记为互斥
  - 其他任何线程试图访问共享数据结构，就必须等到那一段代码执行结束
  - 当访问共享数据前，使用互斥量将相关数据锁住，再当访问结束后，再将数据解锁
  - std::mutex 创建互斥量
    - 通过调用成员函数lock()进行上锁，unlock()进行解锁
  - std::lock_guard  其会在构造的时候提供已锁的互斥量
    - 并在析构的时候进行解锁，从而保证了一个已锁的互斥量总是会被正确的解锁
  - std::lock_guard<std::mutex> guard(int some_mutex);

-精心组织代码来保护共享数据
- 发现接口内在的条件竞争


- 死锁：问题描述及解决方案
  - 试想有一个玩具，这个玩具由两部分组成，必须拿到这两个部分，才能够玩
    - 例如，一个玩具鼓，需要一个鼓锤和一个鼓才能玩
    - 但当他们都紧握着自己所有的部分而不给予，那么这个鼓谁都没法玩
    - 一对线程需要对他们所有的互斥量做一些操作，其中每个线程都有一个互斥量，且等待另一个解锁
      - 这样没有线程能工作，因为他们都在等待对方释放互斥量
      - 这种情况就是死锁，它的最大问题就是由两个或两个以上的互斥量来锁定一个操作
  - 避免死锁的一般建议
    - 就是让两个互斥量总以相同的顺序上锁
    - 总在互斥量B之前锁住互斥量A
  - std::lock  
      - 可以一次性锁住多个(两个以上)的互斥量，并且没有副作用(死锁风险)
  - 避免死锁的进阶指导
    - 避免嵌套锁
    - 避免在持有锁时调用用户提供的代码
    - 使用固定顺序获取锁
    - 使用锁的层次结构

## std::unique_lock——灵活的锁
- 首先，可将 std::adopt_lock 作为第二个参数传入构造函数，对互斥量进行管理
- 也可以将 std::defer_lock 作为第二个参数传递进去，表明互斥量应保持解锁状态
- std::unique_lock<std::mutex> lock_a(lhs.m,std::defer_lock);
- std::lock(lock_a,lock_b);

## 不同域中互斥量所有权的传递
-
