## 笔记
# 海面
- UTexture2D 保存DisplaceMap 以及法线 还有DynamicDisplaceMap
- ENQUEUE_UNIQUE_RENDER_COMMAND
  - 执行代码，只有在渲染线程才执行
# GlobalShader
  - 创建FGlobalShader的一个子类
    - 因此，它将以全局着色器映射表结束（这意味着我们不需要找到它的材质）
    - 如果需要，DECLARE_EXPORTED_SHADER_TYPE（）宏的用法将生成序列化着色器类型所需的导出等
    - 第三个参数是用于着色器模块将存活的代码模块的外部链接的类型（例如， t住在Renderer模块中）。
    - 两个构造函数，默认和序列化。
    - 该ShouldCache（）
      - 以决定是否这个shader应该在某些情况下被编译需要
        - （例如，我们可能不希望编译在非计算着色器能够RHI计算着色器）
    - 在声明该类后，我们现在可以将着色器类型注册到UE4的列表中
  - IMPLEMENT_SHADER_TYPE（，FMyTestVS，TEXT（“MyTest”），TEXT（“MainVS”），SF_Vertex）
    - 该宏将类型（FMyTestVS）映射到.usf文件（MyTest.usf）
    - 着色器入口点（MainVS）以及频率/着色器阶段（SF_Vertex）
    - 只要其ShouldCache（）方法返回true，它也会将着色器添加到编译列表中


# UnOrderedAccessView
  - D3D11中的Resource主要可以分为Buffers和Textures两类
  - Resource可以被绑定到渲染管线的特定阶段，有些绑定是直接的
    - （比如ID3D11DeviceContext::IASetVertexBuffers就直接把一定数量的VertexBuffers绑定到管线的Input Assembler阶段）
  - 也有的绑定必须是间接的
    - 即以Resource View为中间层进行绑定
    - 比如想让Pixel Shader读一个Texture中的内容
  - D3D11中对Resource View的使用只有四种情况，其他的Resource都可以直接绑定
    - 四种使用Resource View的情况如下：
      - 1.Render Target，即把内容渲染到的地方
        - 在初始化D3D11的时候一般都会由DXGISwapChain准备Backbuffers
        - 为其创建一个（或多个）Render Target View
        - 再用ID3D11DeviceContext::OMSetRenderTargets把这些Buffers绑定到管线的末端
        - 此外，在渲染到纹理的时候往往会设置别的Render Target
          - 对应的资源视图是RenderTargetView（RTV）
      - 2.Depth Stencil，也就是深度/模板缓存
        - 同样是在初始化D3D11的时候会用到
        - 对应的资源视图是DepthStencilView（DSV）
      - 3.Shader Resource，指会被着色器访问的一些外部资源，比如纹理（Textures）
        - 对应的资源视图是ShaderResourceView（SRV）。
      - 4.Unordered Access，和Shader Resource相似
        - 但是它不光能被着色器读，还能被着色器写入，所以更加灵活一些
        - 不过它只能绑定于Pixel Shader或Compute Shader
        - 对应的资源视图是UnorderedAccessView（UAV）
# FStructuredBuffer
  - 结构化缓冲区是一个包含相同大小元素的缓冲区
    - 使用具有一个或多个成员类型的结构来定义一个元素
# ShaderResourceView


- Init
  - SetFeatureLevel
  - 初始化参数
  - TResourceArray <> h0_dat ，omega_data  初始化
  - 对UTexture2D的各种图初始化 然后AddToRoot
  - FEvent 了解一下
  - 添加渲染队列ENQUEUE_UNIQUE_RENDER_COMMAND  
    - 让渲染线程执行如下  传参数及函数进去
    - 函数是 InitInRenderThread
      - 获取高度图size
      - FRHIResourceCreateInfo 创建
      - 对FTexture2DRHIRef 赋值
        - 通过 上面初始化的UTexture2D
          - 获取FTexture2DResource ->GetTexture2DRHI()
      - CreateUAV SB SRV  
      - New FFTComputeShader DisMapShader DynamicDisShader
      - 初始化完毕 设定bInit
- ExecuteComputeShader 核心部分
  - 添加渲染队列ENQUEUE_UNIQUE_RENDER_COMMAND
    - 函数是 ExecuteOceanSimulatorComputeShaderInternal
      - 判断是否在渲染线程
      - int 数组 用来存参数的变量
      - 从FRHICommandList 获取FRHICommandListImmediate
//GlobalShader 相关
      - 创建TShaderMapRef<特定的GlobalShader> ComputeShader
        - GetGlobalShaderMap
          - 需要传个FeatureLevel
      - 为GlobalShader SetParamter
      - group_count_x,y 不清楚
      - 调用DispatchComputeShader
      - GlobalShader.UnbindBuffer  传FRHICommandListImmediate
//其他
      - 调用两个GlobleShader 的相应函数
      - RHILockTexture 锁掉Displacementmap
        - 然后一顿骚操作 解锁
      - 获取FRHICommandListImmediate.GenerateMips (GradientMap)
        - 需要了解一下

  - 判断是否有Pawn
  - 不存在的话返回 ，如果存在
    - 获取DynamicPoint以及玩家位置
    - 添加渲染队列ENQUEUE_UNIQUE_RENDER_COMMAND
      - 回掉函数是ExecuteDynamicWaveComputeShaderInternal
