## 笔记

---
# 广义内积
# 调和多项式
# 球面拉普拉斯
# 自伴随矩阵
# 特征空间
# 傅里叶变换
# 勒让德多项式

（x+50）* ( y+50 )/50*50

# 波
  - 振幅A
    - 在波动或振动中距离平衡位置或静止位置的最大位移
  - 波长 λ
    - 指在某一固定的频率里，沿着波的传播方向、在波的图形中
    - 离平衡位置的“位移” 与“时间”皆相同的两个质点之间的最短距离
    - 波长与频率成反比关系
  - 周期
    - 完成往复运动一次所需的时间，物理学上通常以T表示
  - 频率
    - 单位时间内某事件重复发生的次数
## FFT 海洋
  - FOceanSimulatorComputeShader
    - 通过H0和Omega生成Ht
    - UpdateSpectrumCs.usf
  - FRadix008
    - 通过Ht生成DxyzBuffer
    - FRadix008_Cs
  - FDisplaceMapVertexShader
    - 通过DxyzBuffer 生成DisplaceMap
    - UpdateDisplacementPS
  - FGradientMapPixleShader
    - 通过DisplaceMap生成GradientMap
    - GenGradientFoldingPS

  - FDynamicPointComputeShader
    - CreateWaveCs
  - FUpdateWaveComputeShader
      - UpdateWaveCS
  -  FComputeNormalComputeShader
    - ComputeNormal



---
# 材质编辑器
  - Multiply
    - Multiply通常用于使颜色/纹理变亮或变暗。
    - 乘法表达有两个输入端，一起将它们相乘，并输出结果
    - 类似于Photoshop的乘法层混合
    - 每通道发生乘法，这意味着第一通道的R通道乘以第二通道的R通道;
  - Divide
    - 除法表达有两个输入端和所述第一通过第二分割结果输出
    - 除法是按每个频道进行的，也就是说，第一个频道的R频道除以第二个频道，第一个频道的G频道除以第二个频道，以此类推
    - 除非除数是单个浮点值，否则两个输入必须具有相同数量的值
    - 在任何通道中除以零将导致该通道包含本地硬件的“无限”实现，这通常是一个非常大的正值
  - Add
    - 添加通常用于增亮/加深颜色或抵消UV纹理坐标
    - 相加操作是以每个通道为基础执行的，这意味着输入的R通道被加入，G通道被加入，B通道被加入等等
    - 两个输入必须具有相同的通道数量，除非它们中的一个是单个常量值
    - 可以使用任意数量的输入将常数添加到矢量中
  - Subtract
    - 减法可用于使颜色变暗并抵消UV
    - 减法节点发生在两个输入，减去从第一第二输入端，并输出该差值
    - 每个通道发生减法，这意味着第二个输入的R通道从第一个输入中减去; 第二个输入的G通道从第一个输入中减去，依此类推。两个输入必须具有相同的通道数，除非第二个输入是单个常量值。可以使用任意数量的输入从矢量中减去常量
  - Mask
    - 输入为（0.2,0.4,1.0）且G通道的ComponentMask将生成（0.4）的输出
    - 当用作颜色矢量时，该输出显示为40％亮灰度值
  - Append
    - 0.2和0.4的追加是（0.2,0.4）; （0.2,0.4）和（1.0）的追加为（0.2,0.4,1.0）
    - 把通道结合在一起来创建一个比原来多频道的载体
    - 例如，取两个单独的常量值并追加它们以创建一个双通道Constant2Vector值
    - 这对重新排序单个纹理中的通道或将多个灰度纹理合并为一个RGB颜色纹理非常有用
  - Abs
    - 返回x的绝对值
    - 对x的每个元素都会独立计算一次
  - Max
    - 返回x、y中较大值
  - Power
    - 返回x^y
  - Ceil
  - FMod
  - SmoonthStep
    - 如果x的范围是[min, max]，则返回一个介于0和1之间的Hermite插值
  - Lerp
    - 对x、y进行插值计算 Returns x + s(y - x)
  - Normalize
    - 返回单位化向量，定义为 x / length(x)
  - Saturate
    - Clamp 0-1
  - Frac
    - 函数返回参数X的小数部分
---
# 海面
- UTexture2D 保存DisplaceMap 以及法线 还有DynamicDisplaceMap
- ENQUEUE_UNIQUE_RENDER_COMMAND
  - 执行代码，只有在渲染线程才执行
# GlobalShader
  - 创建FGlobalShader的一个子类
    - 因此，它将以全局着色器映射表结束（这意味着我们不需要找到它的材质）
    - 如果需要，DECLARE_EXPORTED_SHADER_TYPE（）宏的用法将生成序列化着色器类型所需的导出等
    - 第三个参数是用于着色器模块将存活的代码模块的外部链接的类型（例如， 在Renderer模块中）。
    - 两个构造函数，默认和序列化。
    - 该ShouldCache（）
      - 以决定是否这个shader应该在某些情况下被编译需要
        - （例如，我们可能不希望编译在非计算着色器能够RHI计算着色器）
    - 在声明该类后，我们现在可以将着色器类型注册到UE4的列表中
  - IMPLEMENT_SHADER_TYPE（，FMyTestVS，TEXT（“MyTest”），TEXT（“MainVS”），SF_Vertex）
    - 该宏将类型（FMyTestVS）映射到.usf文件（MyTest.usf）
    - 着色器入口点（MainVS）以及频率/着色器阶段（SF_Vertex）
    - 只要其ShouldCache（）方法返回true，它也会将着色器添加到编译列表中


# UnOrderedAccessView
  - D3D11中的Resource主要可以分为Buffers和Textures两类
  - Resource可以被绑定到渲染管线的特定阶段，有些绑定是直接的
    - （比如ID3D11DeviceContext::IASetVertexBuffers就直接把一定数量的VertexBuffers绑定到管线的Input Assembler阶段）
  - 也有的绑定必须是间接的
    - 即以Resource View为中间层进行绑定
    - 比如想让Pixel Shader读一个Texture中的内容
  - D3D11中对Resource View的使用只有四种情况，其他的Resource都可以直接绑定
    - 四种使用Resource View的情况如下：
      - 1.Render Target，即把内容渲染到的地方
        - 在初始化D3D11的时候一般都会由DXGISwapChain准备Backbuffers
        - 为其创建一个（或多个）Render Target View
        - 再用ID3D11DeviceContext::OMSetRenderTargets把这些Buffers绑定到管线的末端
        - 此外，在渲染到纹理的时候往往会设置别的Render Target
          - 对应的资源视图是RenderTargetView（RTV）
      - 2.Depth Stencil，也就是深度/模板缓存
        - 同样是在初始化D3D11的时候会用到
        - 对应的资源视图是DepthStencilView（DSV）
      - 3.Shader Resource，指会被着色器访问的一些外部资源，比如纹理（Textures）
        - 对应的资源视图是ShaderResourceView（SRV）
      - 4.Unordered Access，和Shader Resource相似
        - 但是它不光能被着色器读，还能被着色器写入，所以更加灵活一些
        - 不过它只能绑定于Pixel Shader或Compute Shader
        - 对应的资源视图是UnorderedAccessView（UAV）
# FStructuredBuffer
  - 结构化缓冲区是一个包含相同大小元素的缓冲区
    - 使用具有一个或多个成员类型的结构来定义一个元素
# ShaderResourceView


- Init
  - SetFeatureLevel
  - 初始化参数
  - TResourceArray <> h0_dat ，omega_data  初始化
  - 对UTexture2D的各种图初始化 然后AddToRoot
  - FEvent 了解一下
  - 添加渲染队列ENQUEUE_UNIQUE_RENDER_COMMAND  
    - 让渲染线程执行如下  传参数及函数进去
    - 函数是 InitInRenderThread
      - 获取高度图size
      - FRHIResourceCreateInfo 创建
      - 对FTexture2DRHIRef 赋值
        - 通过 上面初始化的UTexture2D
          - 获取FTexture2DResource ->GetTexture2DRHI()
      - CreateUAV SB SRV  
      - New FFTComputeShader DisMapShader DynamicDisShader
      - 初始化完毕 设定bInit
- ExecuteComputeShader 核心部分
  - 添加渲染队列ENQUEUE_UNIQUE_RENDER_COMMAND
    - 函数是 ExecuteOceanSimulatorComputeShaderInternal
      - 判断是否在渲染线程
      - int 数组 用来存参数的变量
      - 从FRHICommandList 获取FRHICommandListImmediate
//GlobalShader 相关
      - 创建TShaderMapRef<特定的GlobalShader> ComputeShader
        - GetGlobalShaderMap
          - 需要传个FeatureLevel
      - 为GlobalShader SetParamter
      - group_count_x,y 不清楚
      - 调用DispatchComputeShader
      - GlobalShader.UnbindBuffer  传FRHICommandListImmediate
//其他
      - 调用两个GlobleShader 的相应函数
      - RHILockTexture 锁掉Displacementmap
        - 然后一顿骚操作 解锁
      - 获取FRHICommandListImmediate.GenerateMips (GradientMap)
        - 需要了解一下

  - 判断是否有Pawn
  - 不存在的话返回 ，如果存在
    - 获取DynamicPoint以及玩家位置
    - 添加渲染队列ENQUEUE_UNIQUE_RENDER_COMMAND
      - 回掉函数是ExecuteDynamicWaveComputeShaderInternal
