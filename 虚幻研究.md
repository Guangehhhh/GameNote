# 虚幻任务


---
## 引擎主循环
  * FEngineLoop::Tick
  * Source\ Runtime\ Launch\ Private\ LaunchEngineLoop.cpp
---
## 渲染线程主循环
  * RenderingThreadMain( FEvent* TaskGraphBoundSyncEvent )
  * 根据目前的是否多线程渲染设置两个参数，这个参数会对前面说的渲染队列有影响
---


## 智能指针
  * 不能指向UObject

---
## Pak读取
  * FCoreDelegates::OnMountPak.Execute(PakPath, 4);

---

---


## Actor删除过程
*  



---


---



---
## UHT 查找各种宏的地方
  \ Source\ Programs\ UnrealHeaderTool\ Private\ HeaderParser.cpp

---
## 动态加载关卡
  * UGameplayStatics::LoadStreamLevel
    * 创建一个FStreamLevelAction
      * Action回去读暴露参数的包遍历所有Level关系找到指定关卡






##  Scene Management
---

# Physics

## Collision碰撞
* 碰撞时相互的，所以两个相互碰撞的实体设置都要满足碰撞条件
* trace
  * trace response就是设置实体本身发射的trace会不会被其他对象响应
* 正确设置staticMesh的碰撞盒类型
  * 每个staticMesh的碰撞盒必须正确对应他的StaticMeshSettings下的CollisionComplexity属性

* Collision Enabled
  * No Collision 踪迹碰撞和物理碰撞都不碰撞
  * No Physics Collision 踪迹碰撞
  * Collision Enabled   全
## 人物的运动受控于两个大组件
* 一个是物理引擎，还有一个是MovementComponent
  * CharacterMovementComponent内部也实现了一个重力移动逻辑，和物理引擎是完全独立
  * CapsuleComponent设置为Overlap
    * 因为他的CharacterMovementComponent内部还是有一个重力逻辑，会使他落下
## AABB轴对齐包围盒
  *  AABB 包围盒是与坐标轴对齐的包围盒
    * 当物体旋转之后需对AABB 进行同样的旋转并更新
    * 物体变形之后只需对变形了的基本几何元素对应的包围盒重新计算
    * 然后可以自下向上由子结点的AABB 合成父结点的AABB, 最后进行包围盒树的更新

## OBB有向包围盒
  * 类似于AABB,但是具有方向性、可以旋转，AABB不能旋转
    * 要计算两个OBB是否碰撞
      * 只需要计算他们在图3上的4个坐标轴上的投影是否有重叠    
      * 如果有，则两多边形有接触
      * 投影轴来自于多边形自身边的垂线
      * 两个多边形在所有轴上的投影都发生重叠，则判定为碰撞；否则，没有发生碰撞

## 关节Joint
---
